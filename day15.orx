map = .map~new
loop with index y item line over .stream~new('day15.txt')~arrayin
    loop with index x item point over line~makeArray('')
        map[x,y] = point
    end
end
if map~dimension(1) \= map~dimension(2) then raise halt

loop i over map~allIndexes
    string = i~makeString(,':') '-> '
    indexes = map~adjacent_indexes(i)
    --say map~adjacent_indexes(i)~items
    loop ii over indexes-- map~adjacent_indexes(i)
        name = name_connection(i, ii)
        say name map[ii]
        --connections.name = map[ii]
        c = .connection~new(i, ii)
        say c
        connections.c = map[ii]
    end
end

loop with index i item cost over connections.
    say ' 'i cost
end
--map~show
say
c = .connection~new((1,1), (2,2))
say c
korvs.c = 'Ã–'
exit

name_connection: procedure
use strict arg source, destination
return source~makeString(,':') '->' destination~makeString(,':') 

::class connection
::method source attribute
::method destination attribute
::method init
    expose source destination
    use strict arg source, destination
    .validate~classType('source', source, .array)
    .validate~classType('destination', destination, .array)
::method makeString
    expose source destination
    return source~makeString(,':') '->' destination~makeString(,':') 

::class map subclass array

::method step
    loop i over self~allIndexes
        self[i] += 1
    end
    return self~flash

::method flash
    adjacents = .array~new
    flashed = .array~new
    loop i over self~allIndexes
        if self[i]~isNil then iterate
        if self[i] > 9 then do
            adjacents~appendAll(self~adjacent_indexes(i))
            flashed~append(i)
            self[i] = .nil
        end
    end
    if adjacents~isEmpty then return 0
    loop i over adjacents
        if self[i]~isNil then iterate
        self[i] += 1
    end
    found = self~flash
    loop i over flashed
        self[i] = 0
    end
    return flashed~items + found

::method adjacent_indexes
    use strict arg index
    x = index[1]; y = index[2]
    output = ((x+1, y), (x, y+1))
    loop with index i item point over output
        x = point[1]; y = point[2]
        select case .true
            when x = 0, x > self~dimension(1) then output~remove(i)
            when y = 0, y > self~dimension(2) then output~remove(i)
            otherwise nop
        end
    end
    return output

::method isClear
    loop i over self
        if i > 0 then return .false
    end
    return .true

::method show
    loop y = 1 to self~dimension(2)
        line = ''
        loop x = 1 to self~dimension(1)
            if self[x,y]~isNil
            then line = line || '-'
            else line = line || self[x,y]~d2x
        end
        say line
    end
    return
